import type { ExportBundleInfo, ExportInfo, ReportData } from "../types.js";
import { formatBytes } from "../utilities/format.utils.js";

function generateMarkdownReport(data: ReportData): string {
  const { packageExports, bundleAnalysis, generatedAt, analysisDuration } =
    data;
  const lines: string[] = [];

  // Header
  lines.push(`# üì¶ Package Analysis: ${packageExports.packageName}`);
  lines.push("");
  lines.push(`> **Version:** \`${packageExports.version}\`  `);
  lines.push(
    `> **Generated:** ${new Date(generatedAt).toLocaleString("nb-no")}  `,
  );
  lines.push(`> **Analysis time:** ${(analysisDuration / 1000).toFixed(1)}s`);
  lines.push("");

  // Summary section
  lines.push("## üìä Summary");
  lines.push("");
  lines.push("| Metric | Value |");
  lines.push("|--------|-------|");
  lines.push(`| üìÅ Export Paths | ${packageExports.summary.totalPaths} |`);
  lines.push(`| üì§ Total Exports | ${packageExports.summary.totalExports} |`);
  lines.push(`| üìù Total Types | ${packageExports.summary.totalTypes} |`);
  lines.push("");

  // Bundle Size section
  if (bundleAnalysis && bundleAnalysis.details.length > 0) {
    lines.push("## üì¶ Bundle Sizes");
    lines.push("");

    const sortedDetails = [...bundleAnalysis.details]
      .filter((d) => d.fullImport)
      .sort(
        (a, b) =>
          (b.fullImport?.minifiedGzip || 0) - (a.fullImport?.minifiedGzip || 0),
      );

    if (sortedDetails.length > 0) {
      lines.push("| Export Path | Raw | Minified | Gzipped |");
      lines.push("|:------------|----:|---------:|--------:|");

      for (const detail of sortedDetails) {
        if (detail.fullImport) {
          const gzipSize = formatBytes(detail.fullImport.minifiedGzip);

          lines.push(
            `| \`${detail.path}\` | ${formatBytes(
              detail.fullImport.raw,
            )} | ${formatBytes(
              detail.fullImport.minified,
            )} | **${gzipSize}** |`,
          );
        }
      }
      lines.push("");
    }

    // Errors/skipped
    const errors = bundleAnalysis.details.filter((d) => d.error);
    const skipped = packageExports.details.filter(
      (d) => !bundleAnalysis.details.some((b) => b.path === d.path),
    );

    if (errors.length > 0 || skipped.length > 0) {
      lines.push("<details>");
      lines.push(
        `<summary>‚ÑπÔ∏è ${
          errors.length + skipped.length
        } paths not analyzed</summary>`,
      );
      lines.push("");
      if (skipped.length > 0) {
        // Categorize skipped paths
        const typeOnly = skipped.filter((s) => s.exports.length === 0);
        const notSelected = skipped.filter((s) => s.exports.length > 0);

        if (typeOnly.length > 0) {
          lines.push("**Type-only (no runtime exports):**");
          for (const s of typeOnly) {
            lines.push(`- \`${s.path}\``);
          }
          lines.push("");
        }
        if (notSelected.length > 0) {
          lines.push("**Not analyzed (use full analysis to include):**");
          for (const s of notSelected) {
            lines.push(`- \`${s.path}\` (${s.exports.length} exports)`);
          }
          lines.push("");
        }
      }
      if (errors.length > 0) {
        lines.push("**Errors:**");
        for (const err of errors) {
          lines.push(`- \`${err.path}\`: ${err.error}`);
        }
      }
      lines.push("");
      lines.push("</details>");
      lines.push("");
    }
  }

  // Exports detail section
  lines.push("## üì§ Exports by Path");
  lines.push("");

  // Group by category (based on path naming)
  const grouped = groupExportsByCategory(
    packageExports.details,
    bundleAnalysis?.details || [],
  );

  for (const [category, items] of Object.entries(grouped)) {
    if (items.length === 0) continue;

    lines.push(`### ${category}`);
    lines.push("");

    for (const { exportInfo, bundleInfo } of items) {
      const exportCount = exportInfo.exports.length;
      const typeCount = exportInfo.types.length;
      const sizeStr = bundleInfo?.fullImport
        ? ` ‚Ä¢ **${formatBytes(bundleInfo.fullImport.minifiedGzip)}** gzip`
        : "";

      lines.push(`<details>`);
      lines.push(
        `<summary><code>${exportInfo.path}</code> ‚Äî ${exportCount} exports, ${typeCount} types${sizeStr}</summary>`,
      );
      lines.push("");

      if (exportCount > 0) {
        lines.push("**Exports:**");
        lines.push("```");
        lines.push(exportInfo.exports.join(", "));
        lines.push("```");
        lines.push("");
      }

      if (typeCount > 0) {
        lines.push("**Types:**");
        lines.push("```");
        lines.push(exportInfo.types.join(", "));
        lines.push("```");
        lines.push("");
      }

      lines.push("</details>");
      lines.push("");
    }
  }

  // Footer
  lines.push("---");
  lines.push("");
  lines.push(
    `*Generated by [package-exports-analyzer](https://github.com/navikt/aksel) on ${new Date(
      generatedAt,
    ).toLocaleString()}*`,
  );

  return lines.join("\n");
}

/**
 * Group exports by category based on path patterns
 */
function groupExportsByCategory(
  exports: ExportInfo[],
  bundleDetails: ExportBundleInfo[],
): Record<string, { exportInfo: ExportInfo; bundleInfo?: ExportBundleInfo }[]> {
  const groups: Record<
    string,
    { exportInfo: ExportInfo; bundleInfo?: ExportBundleInfo }[]
  > = {
    "üì¶ Root": [],
    "üß© Components": [],
    "üîß Utilities": [],
    "üìÇ Other": [],
  };

  const utilPaths = ["locales", "types"];

  for (const exp of exports) {
    const bundleInfo = bundleDetails.find((b) => b.path === exp.path);
    const item = { exportInfo: exp, bundleInfo };
    const pathName = exp.path.replace("./", "");

    if (exp.path === "./package.json") {
      continue;
    }

    if (exp.path === ".") {
      groups["üì¶ Root"].push(item);
    } else if (utilPaths.some((u) => pathName.includes(u))) {
      groups["üîß Utilities"].push(item);
    } else if (exp.exports.length > 0) {
      groups["üß© Components"].push(item);
    } else {
      groups["üìÇ Other"].push(item);
    }
  }

  return groups;
}

export { generateMarkdownReport };
