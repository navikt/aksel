import * as React from 'react';
import * as ReactDOM from 'react-dom';
import * as classnames from 'classnames';

import { EventThrottler, keyCodes, getViewportDimensions, getScrollParents } from 'nav-frontend-js-utils';

import PopoverBase, { PopoverBaseProps, PopoverPosisjonShape, PopoverOrientering } from './popover-base';

const cls = (state, props) => classnames('popover--controlled', {
    'popover--hidden': !state.åpen
});

export interface PopoverProps extends PopoverBaseProps {
    /**
     * Elementet som popover er forankret til. Dette elementet blir brukt til å posisjonere popover.
     */
    ankerEl?: HTMLElement;
    /**
     * Callback når popover åpnes.
     */
    onOpen?: () => void;
    /**
     * Callback når popover ber om å lukkes.
     */
    onClose: () => void;
    /**
     * Avstand til anker element i pixler. Default er `16px` (`1rem`) med pil, eller `0` uten pil.
     */
    avstandTilAnker?: number;
    /**
     * Bestemmer om Popover automatisk skal få fokus når den vises.
     */
    autoFokus?: boolean;
}

interface PopoverState {
    åpen: boolean;
    posisjon?: PopoverPosisjonShape;
}

class Popover extends React.Component<PopoverProps, PopoverState> {
    static defaultProps: Partial<PopoverProps> = {
        autoFokus: true
    };

    private popoverRef = React.createRef<HTMLDivElement>();
    private popoverEl;
    private cachedMeasurements;
    private listenToScrollOn;
    private scrollParents: (HTMLElement|Window)[] = [];

    constructor(props) {
        super(props);

        this.state = {
            åpen: (this.props.ankerEl !== undefined)
        };

        window.addEventListener('click', this.handleClick);
        window.addEventListener('keydown', this.handleKeydown);
    }

    componentDidMount() {
        this.popoverEl = this.popoverRef.current!;
        this.scrollParents = getScrollParents(this.popoverEl);
        this.scrollParents.forEach((scrollParent) => scrollParent.addEventListener('scroll', this.handleScroll));
    }

    componentWillUnmount() {
        window.removeEventListener('click', this.handleClick);
        window.removeEventListener('keydown', this.handleKeydown);
        this.scrollParents.forEach((scrollParent) => scrollParent.removeEventListener('scroll', this.handleScroll));
    }

    componentWillReceiveProps(nextProps) {
        if (!this.props.ankerEl && nextProps.ankerEl) {
            this.setState({
                åpen: true
            }, () => { // tslint:disable-line:align
                this.updatePosition(nextProps);
                if (this.props.autoFokus) this.popoverEl.focus();
            });
        } else if (this.props.ankerEl && !nextProps.ankerEl) {
            this.setState({
                åpen: false
            });
        }
    }

    checkFocus = () => {
        window.setTimeout(() => {
            const focusElement = document.activeElement;
            if (
                focusElement === this.popoverEl ||
                focusElement === this.props.ankerEl ||
                (this.popoverEl.contains && this.popoverEl.contains(focusElement))
            ) {
                return;
            }
            this.props.onClose();
        }, 0); // tslint:disable-line:align
    }

    calculatePosition = (props) => {
        const popoverOffset = this.popoverEl.getBoundingClientRect();
        const ankerOffset = props.ankerEl.getBoundingClientRect();
        let avstandTilAnker = (props.utenPil) ? 0 : 12 ;

        if (typeof props.avstandTilAnker !== 'undefined') {
            avstandTilAnker = props.avstandTilAnker;
        }

        let left;
        let top;

        switch (props.orientering) {
            case PopoverOrientering.OverHøyre:
                left = ankerOffset.x + ankerOffset.width - popoverOffset.width;
                top = ankerOffset.y - avstandTilAnker - popoverOffset.height;
                break;
            case PopoverOrientering.OverVenstre:
                left = ankerOffset.x;
                top = ankerOffset.y - avstandTilAnker - popoverOffset.height;
                break;
            case PopoverOrientering.Venstre:
                left = ankerOffset.x - popoverOffset.width - avstandTilAnker;
                top = ankerOffset.y + (ankerOffset.height / 2) - (popoverOffset.height / 2);
                break;
            case PopoverOrientering.Høyre:
                left = ankerOffset.x + ankerOffset.width + avstandTilAnker;
                top = ankerOffset.y + (ankerOffset.height / 2) - (popoverOffset.height / 2);
                break;
            case PopoverOrientering.UnderHøyre:
                left = ankerOffset.x + ankerOffset.width - popoverOffset.width;
                top = ankerOffset.y + ankerOffset.height + avstandTilAnker;
                break;
            case PopoverOrientering.UnderVenstre:
                left = ankerOffset.x;
                top = ankerOffset.y + ankerOffset.height + avstandTilAnker;
                break;
            case PopoverOrientering.Under:
                left = ankerOffset.x + (ankerOffset.width / 2) - (popoverOffset.width / 2);
                top = ankerOffset.y + ankerOffset.height + avstandTilAnker;
                break;
            default: // PopoverOrientering.Over
                left = ankerOffset.x + (ankerOffset.width / 2) - (popoverOffset.width / 2);
                top = ankerOffset.y - avstandTilAnker - popoverOffset.height;
                break;
        }

        const viewPortDimensions = getViewportDimensions();

        left = Math.max(0, left);
        left = Math.min(Math.abs(left), Math.abs(viewPortDimensions.w - popoverOffset.width));

        const pilLeft = ankerOffset.x + (ankerOffset.width / 2) - left - 1;

        return { left, top, pilLeft };
    }

    getPosition = () => {
        if (!this.state.åpen || !this.state.posisjon) return;
        return {
            left: this.state.posisjon!.left,
            top: this.state.posisjon!.top,
            pilLeft: this.state.posisjon!.pilLeft
        };
    }

    updatePosition = (props) => {
        const posisjon = this.calculatePosition(props);
        this.setState({ posisjon });
    }

    handleClick = (e) => {
        if (this.state.åpen && !ReactDOM.findDOMNode(this.props.ankerEl).contains(e.target)) {
            this.props.onClose();
        }
    }

    handleKeydown = (e) => {
        if (!this.state.åpen) return;
        if (e.keyCode === keyCodes.esc) this.props.onClose();
        if (e.keyCode === keyCodes.tab) this.checkFocus();
    }

    handleResize = () => {
        if (!this.state.åpen) return;
        this.cachedMeasurements = this.popoverEl.getBoundingClientRect();
        this.updatePosition(this.props);
    }

    handleScroll = () => {
        if (!this.state.åpen) return;
        this.updatePosition(this.props);
    }

    render() {
        const { children, ankerEl, onClose, avstandTilAnker, autoFokus, ...rest } = this.props;
        const position = this.getPosition();
        return (
            <EventThrottler event="resize" callback={this.handleResize} delay={100}>
                <PopoverBase
                    className={cls(this.state, this.props)}
                    ref={this.popoverRef}
                    posisjon={position}
                    tabIndex={0}
                    {...rest}
                >
                    {children}
                </PopoverBase>
            </EventThrottler>
        );
    }
}

export default Popover;
export { default as PopoverBase } from './popover-base';
export { PopoverOrientering } from './popover-base';
